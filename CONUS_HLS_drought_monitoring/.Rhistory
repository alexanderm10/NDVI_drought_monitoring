print("Standard deviations by jurisdiction type:")
print(funding_stddev_by_jurisdiction)
cat("\n")
# Step 9: Verification
print("=== STEP 9: Verification ===")
print("Check if funding percentages sum to reasonable totals:")
for(i in 1:nrow(funding_by_jurisdiction)) {
jurisdiction <- funding_by_jurisdiction$jurisdiction_typeupdate[i]
total_pct <- sum(funding_by_jurisdiction[i, 2:6], na.rm = TRUE)
print(paste(jurisdiction, "total funding %:", total_pct))
}
print("\nOverall funding total:")
overall_total <- sum(overall_funding_averages, na.rm = TRUE)
print(paste("Sum of all funding sources:", overall_total, "%"))
print(reporting_summary_table)
print("\nJurisdiction percentage totals should be 100%:")
for(i in 1:nrow(jurisdiction_percentages)) {
jurisdiction <- jurisdiction_percentages$jurisdiction_typeupdate[i]
total_pct <- sum(jurisdiction_percentages[i, 2:8])
print(paste(jurisdiction, "total:", total_pct, "%"))
}
print(jurisdiction_percentages[, c(1:8, 10)])
print(funding_summary_table)
citation('rgee')
citation('mgcv')
library(rgee); library(raster); library(terra)
ee_check() # For some reason, it's important to run this before initializing right now
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor")
path.google <- "/Volumes/GoogleDrive/My Drive"
GoogleFolderSave <- "googleEarthEngine/conusDroughtMonitor"
assetHome <- ee_get_assethome()
assetHome
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor")
ee_check() # For some reason, it's important to run this before initializing right now
ee_check_credentials()
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor", gcs=T)
install.package("googleCloudStorageR")
install.packages("googleCloudStorageR")
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor")
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor", gcs=T)
ee_Authenticate()
4/1AVMBsJgtXabQ4HT5St4QNoJtDNJFskSTDTxV3gwe98uyYkYuCoMZIHnSZaw
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor", gcs=T)
# Check what accounts are currently authenticated
rgee::ee_user_info()
ee_Initialize()
ee_Initialize(user="malexander@anl.gov")
# Remove existing credentials
rgee::ee_clean_credentials()
# Check if authentication was successful
auth_status <- rgee::ee_user_info()
packageVersion("rgee")
update.packages("rgee")
packageVersion("rgee")
# This should work for version 1.1.7
rgee::ee_clean_pyenv()
# Verify Python setup
py_config <- rgee::ee_check_python()
> py_config <- rgee::ee_check_python()
# Try authenticating directly without checking Python config
rgee::ee_Authenticate(user = 'malexander@anl.gov')
4/1AVMBsJiVI8kk-WEHd8sBhAA1FSj-Ip-1DX6cJ42sa8yFyBZoQoCIv4FcH4M
ee_init <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
# This should work in rgee 1.1.7
rgee::ee_clean_user_credentials()
# Fresh authentication
rgee::ee_Authenticate(user = 'malexander@anl.gov')
4/1AVMBsJiDvvjpgB2F4NDDSTg1FQMmm0UBds82cUl8H8rTVK-xF77JVtXozCI
ee_init <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
# Remove the cached credentials manually
credential_file <- "C:/Users/malexander/.config/earthengine/malexander@anl.gov"
if(file.exists(credential_file)) {
file.remove(credential_file)
print("Credential file removed")
} else {
print("Credential file not found")
}
ee_dir <- "C:/Users/malexander/.config/earthengine"
if(dir.exists(ee_dir)) {
files <- list.files(ee_dir, full.names = TRUE, recursive = TRUE)
print("Files found:")
print(files)
}
# unlink is sometimes better at handling permission issues
credential_file <- "C:/Users/malexander/.config/earthengine/malexander@anl.gov"
unlink_result <- unlink(credential_file, force = TRUE)
print(paste("Unlink result:", unlink_result))
# Check if the directory is gone
dir.exists("C:/Users/malexander/.config/earthengine")
# First, let's see what's in the directory
ee_dir <- "C:/Users/malexander/.config/earthengine"
files <- list.files(ee_dir, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
print("Current contents:")
print(files)
# Remove the whole directory with all its contents
ee_dir <- "C:/Users/malexander/.config/earthengine"
removal_result <- unlink(ee_dir, recursive = TRUE, force = TRUE)
print(paste("Directory removal result:", removal_result))
# Check if the directory is completely gone
dir_exists <- dir.exists(ee_dir)
print(paste("Directory still exists:", dir_exists))
# Fresh authentication
library(rgee)
rgee::ee_Authenticate(user = 'malexander@anl.gov')
4/1AVMBsJjZw7GsUIrwfZhjrYlxw0-0pxmxNSAke8uRiFdTl8-1aNBGcsFUF1I
# See what gets created
if(dir.exists(ee_dir)) {
new_files <- list.files(ee_dir, full.names = TRUE, recursive = TRUE)
print("New credential files:")
print(new_files)
} else {
print("No earthengine directory found")
}
# Now try initializing
ee_init <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
4/1AVMBsJjgiOFJs2yXfDeU-x4tGp4GtTbgOxpm7De1uUUAwt9PdenvGURB91E
# Fresh authentication
library(rgee)
rgee::ee_Authenticate(user = 'malexander@anl.gov')
# This will install the earthengine-api package in the correct Python environment
rgee::ee_install_upgrade()
# Set the Python environment to your existing miniconda rgee environment
rgee::ee_install_set_pyenv(py_env = "C:/Users/malexander/AppData/Local/r-miniconda/envs/rgee/python.exe")
# Set the Python environment to your existing miniconda rgee environment
rgee::ee_install_set_pyenv(py_path = "C:/Users/malexander/AppData/Local/r-miniconda/envs/rgee/python.exe")
# Check what environment is now active
Sys.getenv("EARTHENGINE_ENV")
# Set the Python environment to your existing miniconda rgee environment
rgee::ee_install_set_pyenv(py_env = "C:/Users/malexander/AppData/Local/r-miniconda/envs/rgee/python.exe")
# Use py_path instead of py_env
rgee::ee_install_set_pyenv(py_path = "C:/Users/malexander/AppData/Local/r-miniconda/envs/rgee/python.exe")
library(rgee)
# Check that the environment variable is set
Sys.getenv("EARTHENGINE_PYTHON")
# This should now work
rgee::ee_check_python_packages()
# This should now work since the environment is set
rgee::ee_install_upgrade()
ee_install_upgrade(earthengine_env = Sys.getenv("EARTHENGINE_PYTHON"))
# See what conda environments exist
system("conda env list")
# List conda environments using reticulate
reticulate::conda_list()
# Try to use the rgee conda environment
reticulate::use_condaenv("rgee", required = TRUE)
# Restart R completely
.rs.restartR()
# Set the conda environment BEFORE loading any packages
reticulate::use_condaenv("rgee", required = TRUE)
# Verify the correct Python is being used
reticulate::py_config()
# Check if earthengine module exists
reticulate::py_module_available("ee")
# Now load rgee
library(rgee)
# Authenticate
rgee::ee_Authenticate(user = 'malexander@anl.gov')
4/1AVMBsJiUzbomvPiegwGrDoowS4Dnulm2NRsoQ7RtR6oK51yeJdCACAWf_gU
ee_check() # For some reason, it's important to run this before initializing right now
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T, project="conusDroughtMonitor")
4/1AVMBsJhdrK3kDkRPcwqxAr5f1mgJ7gLq-gSqTWxaqEOv0gW8ouOPpTMxPsM
# Restart R completely
.rs.restartR()
# Set the conda environment BEFORE loading any packages
reticulate::use_condaenv("rgee", required = TRUE)
# Verify the correct Python is being used
reticulate::py_config()
# Check if earthengine module exists
reticulate::py_module_available("ee")
# Install earthengine-api
reticulate::py_install("earthengine-api")
# Now load rgee
library(rgee)
# Authenticate
rgee::ee_Authenticate(user = 'malexander@anl.gov')
4/1AVMBsJjBatrDmlbx-MQjuym6shlTSq15dAmOlP7WKu0ztueZoxQcYtnl3Dc
# Initialize with your project
ee_init <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
rgee::ee_Initialize(user = 'malexander@anl.gov', drive=T)
# Initialize without the project parameter to test basic connection
ee_init_basic <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
print(ee_init_basic)
# Test if you can access your specific project
ee_init_project <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
# Try a basic Earth Engine operation to verify connection
test_connection <- try({
ee <- rgee::ee
# Simple test - get Earth Engine version info
ee_info <- ee$data$getInfo()
"Basic Earth Engine connection works"
}, silent = FALSE)
print(test_connection)
# Test if you can access your specific project
ee_init_project <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
####################################################################################################################
#Purpose of Baseline_Data_Models_Norms Workflow: Reorganize and add to existing scripts to form a workflow that will
#                                                be run once to create models & norms based on all data.
#Purpose of Script: Pull all landsat data & store as CSV in shared google drive
# Original scripts written by Christy Rollinson and Juliana Harr, workflow put together by Jocelyn Garcia
####################################################################################################################
library(rgee); library(raster); library(terra)
ee_check() # For some reason, it's important to run this before initializing right now
# Initialize without the project parameter to test basic connection
ee_init_basic <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
print(ee_init_basic)
# Test a simple Earth Engine operation first
test_basic <- try({
ee <- rgee::ee
test_image <- ee$Image("USGS/SRTMGL1_003")
print("Basic Earth Engine operations work!")
}, silent = FALSE)
# Try setting the project through the Earth Engine API
project_test <- try({
ee <- rgee::ee
ee$Initialize(project = "conusDroughtMonitor")
print("Project access successful")
}, silent = FALSE)
# Now try with your specific project
ee_init_project <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
project = "conusDroughtMonitor"
)
# Now try with your specific project
ee_init_project <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE,
)
####################################################################################################################
#Purpose of Baseline_Data_Models_Norms Workflow: Reorganize and add to existing scripts to form a workflow that will
#                                                be run once to create models & norms based on all data.
#Purpose of Script: Pull all landsat data & store as CSV in shared google drive
# Original scripts written by Christy Rollinson and Juliana Harr, workflow put together by Jocelyn Garcia
####################################################################################################################
library(rgee); library(raster); library(terra)
ee_check() # For some reason, it's important to run this before initializing right now
# Verify project access through the Earth Engine interface
project_test <- try({
ee <- rgee::ee
ee$Initialize(project = "conusDroughtMonitor")
"Project access successful"
}, silent = FALSE)
print(project_test)
# Initialize without the project parameter to test basic connection
ee_init_basic <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
####################################################################################################################
#Purpose of Baseline_Data_Models_Norms Workflow: Reorganize and add to existing scripts to form a workflow that will
#                                                be run once to create models & norms based on all data.
#Purpose of Script: Pull all landsat data & store as CSV in shared google drive
# Original scripts written by Christy Rollinson and Juliana Harr, workflow put together by Jocelyn Garcia
####################################################################################################################
library(rgee); library(raster); library(terra)
ee_check() # For some reason, it's important to run this before initializing right now
# Initialize without the project parameter to test basic connection
ee_init_basic <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
print(ee_init_basic)
# Try a basic Earth Engine operation to verify connection
test_connection <- try({
ee <- rgee::ee
# Simple test - get Earth Engine version info
ee_info <- ee$data$getInfo()
"Basic Earth Engine connection works"
}, silent = FALSE)
print(test_connection)
# Initialize without the project parameter to test basic connection
ee_init_basic <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
print(ee_init_basic)
# Test a simple Earth Engine operation first
test_basic <- try({
ee <- rgee::ee
test_image <- ee$Image("USGS/SRTMGL1_003")
print("Basic Earth Engine operations work!")
}, silent = FALSE)
# Try setting the project through the Earth Engine API
project_test <- try({
ee <- rgee::ee
ee$Initialize(project = "conusDroughtMonitor")
print("Project access successful")
}, silent = FALSE)
library(rgee); library(raster); library(terra)
ee_check() # For some reason, it's important to run this before initializing right now
reticulate::use_condaenv("rgee", required = TRUE)  # Set this first after R restart
ee_init <- rgee::ee_Initialize(
user = 'malexander@anl.gov',
drive = TRUE
)
ee <- rgee::ee
ee$Initialize(project = "conusDroughtMonitor")
# Now you can use Earth Engine with your project
test_image <- ee$Image("USGS/SRTMGL1_003")
print(test_image)
load("U:/datasets/gdo_wildfire_fy25/processed_data/lag_analysis_results/seasonal_specific/all_seasonal_analysis_results.rds")
readRDS("U:/datasets/gdo_wildfire_fy25/processed_data/lag_analysis_results/seasonal_specific/all_seasonal_analysis_results.rds")
dat.check <- readRDS("U:/datasets/gdo_wildfire_fy25/processed_data/lag_analysis_results/seasonal_specific/all_seasonal_analysis_results.rds")
summary(dat.check)
summary(dat.check$results$vpd)
summary(dat.check$results$vpd$data_rows)
head(dat.check$results$vpd$data_rows)
head(dat.check$results$vpd)
head(dat.check$results$vpd$seasonal_summary)
# Load a sample dataset
data(iris)
# Define predictors and response
X <- iris[, 1:4]  # Predictors (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
y <- iris$Sepal.Length  # Response variable
# Fit a PPR model
ppr_model <- ppr(X, y, nterms = 2, sm.method = "spline")
# View model summary
summary(ppr_model)
# Predict using the model
predictions <- predict(ppr_model, X)
# Plot the smooth functions
plot(ppr_model)
vpd_seasonal_ppr_results <- readRDS("U:/datasets/gdo_wildfire_fy25/processed_data/ppr_results/seasonal_specific/vpd_seasonal_ppr_results.rds")
summary(vpd_seasonal_ppr_results)
head(vpd_seasonal_ppr_results)
summary(vpd_seasonal_ppr_results$config$model_spec)
vpd_seasonal_ppr_results$config$model_spec
vpd_seasonal_ppr_results$local_results
vpd_seasonal_ppr_results$local_results[1]
vpd_seasonal_ppr_results$local_results[[1]]
citation("rgee")
---
title: "TASK 1: DROUGHT PLANNING PLATFORM"
---
title: "TASK 1: DROUGHT PLANNING PLATFORM"
install.packages("htmltools")
install.packages("htmltools")
setwd("~/r_files/drought_grant/NDVI_drought_monitoring/CONUS_HLS_drought_monitoring")
source("CONUS_HLS_drought_monitoring/match_ndvi_fmask.R")
source("match_ndvi_fmask.R")
matched <- run_matching_report()
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
Q
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
library(terra)
# Check one of the failing scenes
red <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B04.tif")
nir <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B05.tif")
# Check data types
cat("Red datatype:", datatype(red), "\n")
cat("NIR datatype:", datatype(nir), "\n")
# Try the calculation
test <- (nir - red) / (nir + red)
plot(test)
summary(test)
library(terra)
red <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B04.tif")
nir <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B05.tif")
fmask <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_Fmask.tif")
# Calculate NDVI
ndvi <- (nir - red) / (nir + red)
ndvi[ndvi < -1 | ndvi > 1] <- NA
# Check Fmask alignment
if (!compareGeom(ndvi, fmask)) {
fmask <- resample(fmask, ndvi, method = "near")
}
# Try bitwise operations
quality_mask <- (
bitwAnd(fmask, bitwShiftL(1, 1)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 2)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 3)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 4)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 5)) == 0
)
# Try bitwise operations
quality_mask <- (
bitwAnd(fmask, bitwShiftL(1, 1)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 2)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 3)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 4)) == 0 &
bitwAnd(fmask, bitwShiftL(1, 5)) == 0
)
# Get fmask values as a raster for bitwise operations
fmask_vals <- fmask[[1]]  # Get the actual layer
quality_mask <- (
bitwAnd(fmask_vals, 2) == 0 &    # bit 1 = 2^1 = 2 (cloud)
bitwAnd(fmask_vals, 4) == 0 &    # bit 2 = 2^2 = 4 (adjacent)
bitwAnd(fmask_vals, 8) == 0 &    # bit 3 = 2^3 = 8 (shadow)
bitwAnd(fmask_vals, 16) == 0 &   # bit 4 = 2^4 = 16 (snow/ice)
bitwAnd(fmask_vals, 32) == 0     # bit 5 = 2^5 = 32 (water)
)
library(terra)
red <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B04.tif")
nir <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_B05.tif")
fmask <- rast("U:/datasets/ndvi_monitor/raw_hls_data/year_2013/midwest_01_01/HLS.L30.T13SEA.2013102T173342.v2.0_Fmask.tif")
# Calculate NDVI
ndvi <- (nir - red) / (nir + red)
ndvi[ndvi < -1 | ndvi > 1] <- NA
# Check Fmask alignment
if (!compareGeom(ndvi, fmask)) {
fmask <- resample(fmask, ndvi, method = "near")
}
# Get fmask values as a raster for bitwise operations
fmask_vals <- fmask[[1]]  # Get the actual layer
head(fmask_vals)
quality_mask <- (
bitwAnd(fmask_vals, 2) == 0 &    # bit 1 = 2^1 = 2 (cloud)
bitwAnd(fmask_vals, 4) == 0 &    # bit 2 = 2^2 = 4 (adjacent)
bitwAnd(fmask_vals, 8) == 0 &    # bit 3 = 2^3 = 8 (shadow)
bitwAnd(fmask_vals, 16) == 0 &   # bit 4 = 2^4 = 16 (snow/ice)
bitwAnd(fmask_vals, 32) == 0     # bit 5 = 2^5 = 32 (water)
)
bitwAnd()
?bitwAnd()
length(fmask_vals==2)
length(fmask_vals)
# Get fmask values as a raster for bitwise operations
fmask_vals <- fmask[[1]]  # Get the actual layer
quality_mask <- (
bitwAnd(fmask_vals, 2) == 0 &    # bit 1 = 2^1 = 2 (cloud)
bitwAnd(fmask_vals, 4) == 0 &    # bit 2 = 2^2 = 4 (adjacent)
bitwAnd(fmask_vals, 8) == 0 &    # bit 3 = 2^3 = 8 (shadow)
bitwAnd(fmask_vals, 16) == 0 &   # bit 4 = 2^4 = 16 (snow/ice)
bitwAnd(fmask_vals, 32) == 0     # bit 5 = 2^5 = 32 (water)
)
bitwAnd(fmask_vals, 2) == 0 &
bitwAnd(fmask_vals, 4) == 0
bitwAnd(fmask_vals, 8) == 0
cat("Fmask datatype:", datatype(fmask), "\n")
cat("Fmask class:", class(fmask), "\n")
packageVersion('terra')
quality_mask <- (
(fmask %% 4) < 2 &    # Bit 1 not set (cloud)
(fmask %% 8) < 4 &    # Bit 2 not set (adjacent)
(fmask %% 16) < 8 &   # Bit 3 not set (shadow)
(fmask %% 32) < 16 &  # Bit 4 not set (snow/ice)
(fmask %% 64) < 32    # Bit 5 not set (water)
)
# Try masking
ndvi_masked <- mask(ndvi, quality_mask, maskvalue = 0, updatevalue = NA)
plot(ndvi_masked)
summary(ndvi_masked)
source("reprocess_ndvi_with_fmask.R")
results <- run_ndvi_reprocessing(overwrite = TRUE)
warnings()
# retrying failed downloads.
source("CONUS_HLS_drought_monitoring/redownload_failed_scenes.R")
# retrying failed downloads.
source("redownload_failed_scenes.R")
results <- run_failed_scene_recovery()
# retrying failed downloads.
source("redownload_failed_scenes.R")
results <- run_failed_scene_recovery()
# retrying failed downloads.
source("recover_failed_scenes.R")
results <- run_scene_recovery()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison.R")
results <- run_hls_sensor_diagnostic()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison_v2.R")
results <- run_hls_sensor_diagnostic()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison_v2.R")
results <- run_hls_sensor_diagnostic()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison_v2.R")
results <- run_hls_sensor_diagnostic()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison_v2.R")
results <- run_hls_sensor_diagnostic()
# rerun sensor diagnostic to check for parity
source("diagnostic_hls_sensor_comparison_v2.R")
results <- run_hls_sensor_diagnostic()
